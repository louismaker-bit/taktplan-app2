<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Taktplan-Auswerter</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    label { display:block; font-weight: 600; margin: 12px 0 6px; }
    textarea { width: 100%; min-height: 140px; font-size: 14px; }
    select, input { width: 100%; padding: 10px; font-size: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin-top: 14px; }
    .ok { border-color: #b7e1c1; background: #f3fff6; }
    .err { border-color: #f2b8b5; background: #fff5f5; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    button { width: 100%; padding: 12px; font-size: 16px; border-radius: 12px; border: 1px solid #ccc; background: #f7f7f7; }
    .small { font-size: 12px; color: #666; }
    table { width:100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align:left; font-size: 14px; }
    th { font-weight: 700; }
    .pill { display:inline-block; padding: 2px 8px; border:1px solid #ddd; border-radius: 999px; font-size: 12px; background:#fafafa; }
  </style>
</head>
<body>
  <h1>Taktplan-Auswerter (offline + Komfort)</h1>

  <div class="card">
    <label for="planSelect">Gespeicherter Plan (aktiv)</label>
    <select id="planSelect"></select>
    <div class="row" style="margin-top:10px;">
      <button id="loadSaved">Laden</button>
      <button id="deleteSaved">Löschen</button>
    </div>
    <div class="small" style="margin-top:8px;">
      Auto-Save überschreibt automatisch den aktiven Plan nach erfolgreichem Apply (wenn aktiviert).
    </div>
  </div>

  <label for="table">Plan einfügen (OCR oder Tabelle)</label>
  <textarea id="table" placeholder="OCR-Beispiel:
1 Airbag LISA 2 Bepl. Re. BESETZT 3 Ablage Li. EVGENIJ ...

Tabellen-Beispiel:
1;Airbag;LISA"></textarea>

  <div class="row">
    <div>
      <label for="rounds">Runden pro Tag</label>
      <input id="rounds" type="number" min="1" max="12" value="4" />
    </div>
    <div>
      <label for="autoApply">Automatik</label>
      <select id="autoApply">
        <option value="on" selected>Auto-Apply: EIN</option>
        <option value="off">Auto-Apply: AUS</option>
      </select>
    </div>
  </div>

  <div class="row">
    <div>
      <label for="autoSave">Auto-Save (aktiver Plan)</label>
      <select id="autoSave">
        <option value="on" selected>Auto-Save: EIN</option>
        <option value="off">Auto-Save: AUS</option>
      </select>
    </div>
    <div style="display:flex; align-items:flex-end;">
      <button id="applyBtn">Plan anwenden (manuell)</button>
    </div>
  </div>

  <div class="card">
    <label for="planName">Speichern als (Name)</label>
    <input id="planName" placeholder="z.B. Standardwoche / KW03 / Änderung Mittwoch" />
    <div class="row" style="margin-top:10px;">
      <button id="saveNew">Als neuen Plan speichern</button>
      <button id="overwriteActive">Aktiven Plan überschreiben</button>
    </div>
    <div class="small" style="margin-top:8px;">
      Tipp: Leg dir A/B-Pläne an (Standard / Änderung) und wechsle bei Bedarf mit „Laden“.
    </div>
  </div>

  <div class="row">
    <div>
      <label for="employee">Mitarbeiter</label>
      <select id="employee" disabled></select>
    </div>
    <div>
      <label for="day">Tag</label>
      <select id="day" disabled>
        <option value="mo">Mo</option>
        <option value="di">Di</option>
        <option value="mi">Mi</option>
        <option value="do">Do</option>
        <option value="fr">Fr</option>
        <option value="sa">Sa</option>
        <option value="so">So</option>
      </select>
    </div>
  </div>

  <div class="row">
    <div>
      <label for="round">Runde</label>
      <select id="round" disabled></select>
    </div>
    <div>
      <label>&nbsp;</label>
      <button id="queryBtn" disabled>Abfrage</button>
    </div>
  </div>

  <div class="row">
    <div>
      <button id="weekBtn" disabled>Wochenübersicht (Mo–Fr)</button>
    </div>
    <div>
      <button id="clearBtn">Eingabe leeren</button>
    </div>
  </div>

  <div id="result" class="card" style="display:none;"></div>
  <div id="week" class="card" style="display:none;"></div>

<script>
  // ---------- constants ----------
  const DAY_ALIASES = { mo:0, di:1, mi:2, do:3, fr:4, sa:5, so:6 };
  const DAY_NAMES = ["Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag","Sonntag"];

  // ---------- storage keys ----------
  const STORAGE_KEY = "taktplan_saved_v2";       // { plans: {id:{name,text,rounds,updatedAt}}, activeId }
  const LAST_DRAFT_KEY = "taktplan_last_draft_v2"; // { text, rounds, autoApply, autoSave }
  const LAST_QUERY_KEY = "taktplan_last_query_v1"; // { employee, day, round }

  // ---------- helpers ----------
  function normName(s) { return (s || "").trim().replace(/\s+/g, " ").toUpperCase(); }
  function nowISO() { return new Date().toISOString(); }
  function uid() { return "p_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16); }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return { plans: {}, activeId: null };
      const parsed = JSON.parse(raw);
      return { plans: parsed.plans || {}, activeId: parsed.activeId || null };
    } catch { return { plans: {}, activeId: null }; }
  }
  function saveState(state) { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

  function saveDraft() {
    localStorage.setItem(LAST_DRAFT_KEY, JSON.stringify({
      text: elTable.value,
      rounds: elRounds.value,
      autoApply: elAutoApply.value,
      autoSave: elAutoSave.value
    }));
  }
  function loadDraft() {
    try {
      const raw = localStorage.getItem(LAST_DRAFT_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  function saveLastQuery() {
    localStorage.setItem(LAST_QUERY_KEY, JSON.stringify({
      employee: elEmp.value,
      day: elDay.value,
      round: elRound.value
    }));
  }
  function loadLastQuery() {
    try {
      const raw = localStorage.getItem(LAST_QUERY_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  function showOk(html) {
    elResult.style.display = "block";
    elResult.className = "card ok";
    elResult.innerHTML = html;
  }
  function showErr(msg) {
    elResult.style.display = "block";
    elResult.className = "card err";
    elResult.innerHTML = `<div><strong>Fehler:</strong> ${msg}</div>`;
  }
  function hideWeek() {
    elWeek.style.display = "none";
    elWeek.innerHTML = "";
  }

  function setEnabled(on) {
    elEmp.disabled = !on;
    elDay.disabled = !on;
    elRound.disabled = !on;
    elQuery.disabled = !on;
    elWeekBtn.disabled = !on;
  }

  function fillRounds(n) {
    elRound.innerHTML = "";
    for (let i = 1; i <= n; i++) {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = String(i);
      elRound.appendChild(opt);
    }
  }

  // ---------- parsing: supports table and OCR single-line ----------
  function parseTable(text) {
    const raw = (text || "").trim();
    if (!raw) return [];

    // If contains separators, treat as table mode
    const looksLikeTable = /[;\t,]/.test(raw);

    // MODE A: table paste
    if (looksLikeTable) {
      const rows = [];
      const lines = raw.split(/\r?\n/);
      for (const line0 of lines) {
        const line = line0.trim();
        if (!line) continue;

        const parts = line.split(/[\t;,]+/).map(x => x.trim()).filter(Boolean);
        if (parts.length < 3) continue;

        let takt = null, idx = null;
        for (let i = 0; i < Math.min(2, parts.length); i++) {
          if (/^\d+$/.test(parts[i])) { takt = parseInt(parts[i], 10); idx = i; break; }
        }
        if (takt === null) continue;
        if (idx + 2 >= parts.length) continue;

        rows.push({ takt, bezeichnung: parts[idx + 1], mitarbeiter: parts[idx + 2] });
      }
      rows.sort((a,b) => a.takt - b.takt);
      return rows;
    }

    // MODE B: OCR single line
    const cleaned = raw.replace(/\r?\n/g, " ").replace(/\s+/g, " ").trim();
    const tokens = cleaned.split(" ").filter(Boolean);

    const segments = [];
    let i = 0;
    while (i < tokens.length) {
      if (!/^\d+$/.test(tokens[i])) { i++; continue; }
      const takt = parseInt(tokens[i], 10);
      i++;

      const content = [];
      while (i < tokens.length && !/^\d+$/.test(tokens[i])) {
        content.push(tokens[i]);
        i++;
      }
      if (content.length >= 2) segments.push({ takt, content });
    }

    const rows = segments.map(seg => {
      const mitarbeiter = seg.content[seg.content.length - 1];
      const bezeichnung = seg.content.slice(0, -1).join(" ").trim();
      return { takt: seg.takt, bezeichnung, mitarbeiter };
    });

    rows.sort((a,b) => a.takt - b.takt);
    return rows;
  }

  // ---------- plan logic ----------
  class TaktPlan {
    constructor(rows, roundsPerDay) {
      if (!rows || rows.length === 0) throw new Error("Keine gültigen Zeilen erkannt. Prüfe das Format.");
      this.rows = rows;
      this.roundsPerDay = roundsPerDay;

      this.cycle = rows.filter(r => normName(r.mitarbeiter) !== "BESETZT");
      if (this.cycle.length === 0) throw new Error("Alle Einträge sind BESETZT – kein Rotationszyklus möglich.");

      this.startIndex = new Map();
      this.cycle.forEach((r, i) => {
        const key = normName(r.mitarbeiter);
        if (!this.startIndex.has(key)) this.startIndex.set(key, i);
      });
    }

    assignment(employee, dayKey, roundNo) {
      if (roundNo < 1 || roundNo > this.roundsPerDay) throw new Error(`Runde muss 1-${this.roundsPerDay} sein.`);
      const empKey = normName(employee);
      if (!this.startIndex.has(empKey)) throw new Error(`Mitarbeiter '${employee}' nicht im Plan gefunden.`);

      const d = DAY_ALIASES[dayKey];
      if (d === undefined) throw new Error("Unbekannter Tag.");

      const steps = d * this.roundsPerDay + (roundNo - 1);
      const start = this.startIndex.get(empKey);
      const pos = (start + steps) % this.cycle.length;
      return this.cycle[pos];
    }

    weeklyOverview(employee, days=5) {
      const out = [];
      for (let d = 0; d < days; d++) {
        for (let r = 1; r <= this.roundsPerDay; r++) {
          const dayKey = Object.keys(DAY_ALIASES).find(k => DAY_ALIASES[k] === d);
          const row = this.assignment(employee, dayKey, r);
          out.push({ tag: DAY_NAMES[d], runde: r, station: row.bezeichnung, takt: row.takt });
        }
      }
      return out;
    }
  }

  // ---------- diagnostics ----------
  function diagnostics(rows) {
    const takts = rows.map(r => r.takt);
    const uniq = new Set(takts);
    const dups = takts.filter((t, idx) => takts.indexOf(t) !== idx);
    const min = Math.min(...takts);
    const max = Math.max(...takts);

    // missing in range (useful if plan is expected 1..18)
    const missing = [];
    for (let t = min; t <= max; t++) {
      if (!uniq.has(t)) missing.push(t);
    }

    return { count: rows.length, uniq: uniq.size, min, max, dups: Array.from(new Set(dups)), missing };
  }

  // ---------- UI elements ----------
  const elTable = document.getElementById("table");
  const elRounds = document.getElementById("rounds");
  const elAutoApply = document.getElementById("autoApply");
  const elAutoSave = document.getElementById("autoSave");
  const elApplyBtn = document.getElementById("applyBtn");

  const elPlanSelect = document.getElementById("planSelect");
  const elLoadSaved = document.getElementById("loadSaved");
  const elDeleteSaved = document.getElementById("deleteSaved");

  const elPlanName = document.getElementById("planName");
  const elSaveNew = document.getElementById("saveNew");
  const elOverwriteActive = document.getElementById("overwriteActive");

  const elEmp = document.getElementById("employee");
  const elDay = document.getElementById("day");
  const elRound = document.getElementById("round");
  const elQuery = document.getElementById("queryBtn");
  const elWeekBtn = document.getElementById("weekBtn");
  const elClear = document.getElementById("clearBtn");

  const elResult = document.getElementById("result");
  const elWeek = document.getElementById("week");

  let plan = null;
  let applyTimer = null;

  function refreshPlanSelect() {
    const state = loadState();
    const entries = Object.entries(state.plans)
      .map(([id, p]) => ({ id, ...p }))
      .sort((a,b) => (b.updatedAt || "").localeCompare(a.updatedAt || ""));

    elPlanSelect.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "— keinen auswählen —";
    elPlanSelect.appendChild(opt0);

    for (const p of entries) {
      const opt = document.createElement("option");
      opt.value = p.id;
      const stamp = p.updatedAt ? p.updatedAt.slice(0,16).replace("T"," ") : "";
      opt.textContent = `${p.name} (${stamp})`;
      elPlanSelect.appendChild(opt);
    }
    elPlanSelect.value = state.activeId || "";
  }

  function applyPlan({silent=false} = {}) {
    const text = elTable.value;
    const rpd = parseInt(elRounds.value, 10) || 4;
    hideWeek();

    const rows = parseTable(text);
    const diag = diagnostics(rows);

    plan = new TaktPlan(rows, rpd);

    // fill employees
    const names = Array.from(new Set(plan.cycle.map(r => r.mitarbeiter.trim())))
      .sort((a,b) => normName(a).localeCompare(normName(b)));

    elEmp.innerHTML = "";
    for (const name of names) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      elEmp.appendChild(opt);
    }

    fillRounds(rpd);
    setEnabled(true);

    // restore last query if possible
    const last = loadLastQuery();
    if (last) {
      if (names.includes(last.employee)) elEmp.value = last.employee;
      if (last.day) elDay.value = last.day;
      if (last.round) elRound.value = last.round;
    }

    const state = loadState();
    const activeId = state.activeId;

    // Auto-save active plan after successful apply
    if (elAutoSave.value === "on" && activeId && state.plans[activeId]) {
      state.plans[activeId] = { ...state.plans[activeId], text, rounds: rpd, updatedAt: nowISO() };
      saveState(state);
      refreshPlanSelect();
    }

    if (!silent) {
      const warnBits = [];
      if (diag.dups.length) warnBits.push(`Doppelte Takte: ${diag.dups.join(", ")}`);
      if (diag.missing.length) warnBits.push(`Fehlende Takte (${diag.min}–${diag.max}): ${diag.missing.join(", ")}`);

      showOk(`
        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <span class="pill">Erkannt: <strong>${diag.count}</strong></span>
          <span class="pill">Zyklus ohne BESETZT: <strong>${plan.cycle.length}</strong></span>
          <span class="pill">Runden/Tag: <strong>${rpd}</strong></span>
          ${activeId ? `<span class="pill">Aktiv: <strong>Auto-Save ${elAutoSave.value === "on" ? "EIN" : "AUS"}</strong></span>` : `<span class="pill">Kein aktiver Plan ausgewählt</span>`}
        </div>
        ${warnBits.length ? `<div style="margin-top:10px;"><strong>Hinweise:</strong><br>${warnBits.join("<br>")}</div>` : ``}
      `);
    }
  }

  function scheduleAutoApply() {
    if (elAutoApply.value !== "on") return;
    if (applyTimer) clearTimeout(applyTimer);
    applyTimer = setTimeout(() => {
      try {
        if (!elTable.value.trim()) return;
        applyPlan({silent:true});
      } catch (e) {
        // keep quiet on auto, but enable manual diagnosis:
        // do nothing here; user can hit "Plan anwenden" to see error
      }
    }, 600);
  }

  // ---------- init ----------
  (function init() {
    const draft = loadDraft();
    if (draft) {
      if (draft.text) elTable.value = draft.text;
      if (draft.rounds) elRounds.value = draft.rounds;
      if (draft.autoApply) elAutoApply.value = draft.autoApply;
      if (draft.autoSave) elAutoSave.value = draft.autoSave;
    }
    refreshPlanSelect();
    setEnabled(false);
  })();

  // ---------- events ----------
  elTable.addEventListener("input", () => { saveDraft(); scheduleAutoApply(); });
  elRounds.addEventListener("input", () => { saveDraft(); scheduleAutoApply(); });
  elAutoApply.addEventListener("change", () => saveDraft());
  elAutoSave.addEventListener("change", () => saveDraft());

  elApplyBtn.addEventListener("click", () => {
    try { applyPlan({silent:false}); }
    catch (e) { plan = null; setEnabled(false); showErr(e.message || String(e)); }
  });

  elQuery.addEventListener("click", () => {
    try {
      if (!plan) throw new Error("Bitte erst den Plan anwenden (oder Auto-Apply nutzen).");
      const employee = elEmp.value;
      const dayKey = elDay.value;
      const roundNo = parseInt(elRound.value, 10);

      const row = plan.assignment(employee, dayKey, roundNo);
      const dayName = DAY_NAMES[DAY_ALIASES[dayKey]];

      saveLastQuery();
      hideWeek();

      showOk(`
        <div><strong>${employee}</strong> hat <strong>${dayName}</strong>, Runde <strong>${roundNo}</strong>:</div>
        <div style="font-size:18px; margin-top:6px;"><strong>${row.bezeichnung}</strong></div>
        <div class="mono" style="margin-top:6px;">Takt ${row.takt}</div>
      `);
    } catch (e) {
      showErr(e.message || String(e));
    }
  });

  elWeekBtn.addEventListener("click", () => {
    try {
      if (!plan) throw new Error("Bitte erst den Plan anwenden (oder Auto-Apply nutzen).");
      const employee = elEmp.value;

      const data = plan.weeklyOverview(employee, 5);
      saveLastQuery();

      elWeek.style.display = "block";
      elWeek.className = "card";
      elWeek.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div><strong>Wochenübersicht (Mo–Fr): ${employee}</strong></div>
          <div class="small">Runden/Tag: ${plan.roundsPerDay}</div>
        </div>
        <table>
          <thead><tr><th>Tag</th><th>Runde</th><th>Station</th><th>Takt</th></tr></thead>
          <tbody>
            ${data.map(r => `<tr><td>${r.tag}</td><td>${r.runde}</td><td>${r.station}</td><td>${r.takt}</td></tr>`).join("")}
          </tbody>
        </table>
      `;
    } catch (e) {
      showErr(e.message || String(e));
    }
  });

  elClear.addEventListener("click", () => {
    elTable.value = "";
    saveDraft();
    plan = null;
    setEnabled(false);
    hideWeek();
    showOk("Eingabe geleert.");
  });

  elSaveNew.addEventListener("click", () => {
    try {
      const name = (elPlanName.value || "").trim();
      if (!name) throw new Error("Bitte einen Namen eingeben (z.B. 'Standardwoche').");

      const text = elTable.value;
      const rounds = parseInt(elRounds.value, 10) || 4;
      if (!text.trim()) throw new Error("Plan-Text ist leer.");

      // validate
      const rows = parseTable(text);
      new TaktPlan(rows, rounds);

      const state = loadState();
      const id = uid();
      state.plans[id] = { name, text, rounds, updatedAt: nowISO() };
      state.activeId = id;
      saveState(state);
      refreshPlanSelect();

      showOk(`Als neuer Plan gespeichert und aktiviert: <strong>${name}</strong>`);
    } catch (e) {
      showErr(e.message || String(e));
    }
  });

  elOverwriteActive.addEventListener("click", () => {
    try {
      const state = loadState();
      const id = state.activeId;
      if (!id || !state.plans[id]) throw new Error("Kein aktiver Plan ausgewählt.");

      const text = elTable.value;
      const rounds = parseInt(elRounds.value, 10) || 4;
      if (!text.trim()) throw new Error("Plan-Text ist leer.");

      // validate
      const rows = parseTable(text);
      new TaktPlan(rows, rounds);

      state.plans[id] = { ...state.plans[id], text, rounds, updatedAt: nowISO() };
      saveState(state);
      refreshPlanSelect();

      showOk(`Aktiver Plan überschrieben: <strong>${state.plans[id].name}</strong>`);
    } catch (e) {
      showErr(e.message || String(e));
    }
  });

  elLoadSaved.addEventListener("click", () => {
    try {
      const state = loadState();
      const id = elPlanSelect.value;
      if (!id || !state.plans[id]) throw new Error("Kein gespeicherter Plan ausgewählt.");

      const p = state.plans[id];
      elTable.value = p.text || "";
      elRounds.value = p.rounds || 4;
      saveDraft();

      state.activeId = id;
      saveState(state);
      refreshPlanSelect();

      applyPlan({silent:false});
      showOk(`Plan geladen & angewendet: <strong>${p.name}</strong>`);
    } catch (e) {
      showErr(e.message || String(e));
    }
  });

  elDeleteSaved.addEventListener("click", () => {
    try {
      const state = loadState();
      const id = elPlanSelect.value;
      if (!id || !state.plans[id]) throw new Error("Kein gespeicherter Plan ausgewählt.");
      const name = state.plans[id].name || id;

      delete state.plans[id];
      if (state.activeId === id) state.activeId = null;
      saveState(state);
      refreshPlanSelect();

      showOk(`Plan gelöscht: <strong>${name}</strong>`);
    } catch (e) {
      showErr(e.message || String(e));
    }
  });
</script>
</body>
</html>
